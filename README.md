# Thesis-Redis-IO_Uring

This repository contains the code and scripts for evaluating Redis with `io_uring` as part of my thesis. The project integrates the official [`redis`](https://github.com/redis/redis) repository as a git submodule. Additionally, it includes my custom implementation as a git submodule [`redis-io_uring`](https://github.com/daraccrafter/redis-io_uring/tree/unstable).

## Prerequisites

Before getting started, ensure your system meets the following requirements:

- **Kernel Version**: Ensure your kernel version is >= 5.1 to support `liburing`.

## Installing Dependencies and Building

### Ubuntu & Debian-based

Run the `./setup.sh` script. This script will:

1. Pull both `redis` and `redis-io_uring` git submodules, if not already pulled.
2. Install all necessary dependencies.
3. Build both `redis` and `redis-io_uring`.

Simply execute the following command in your terminal:

```sh
./setup.sh
```

### Manually Installing Dependencies

If you prefer to install dependencies manually, ensure you have the following installed on your system:

- `make`
- `gcc`
- `python3`
- Python libraries: `pandas`, `psutil`, `matplotlib`, `redis` (You can also install these with `pip3`)

Follow these steps:

1. **Pull Git Submodules**:

   If you didn't pull the repository with `--recurse-submodules`, initialize and update the submodules:

   ```sh
   git submodule update --init --recursive
   ```

2. **Build Redis and Redis-IO_Uring**:

   Navigate to the project root directory and run the following commands to build `redis` and `redis-io_uring`:

   ```sh
   make -C redis
   make -C redis-io_uring
   ```

3. **Copy Redis Tools**:

   Copy the `redis-benchmark` and `redis-check-aof` tools to the `scripts` directory:

   ```sh
   cp redis/src/redis-benchmark scripts/
   cp redis/src/redis-check-aof scripts/
   ```

## Running Redis

To run Redis, navigate to either the `redis` or `redis-io_uring` directory and execute the following command:

```sh
./src/redis-server redis.conf
```

### Configuration Options redis-io_uring

Additional configuration options can be set in the `redis.conf` file. Here are the liburing configurations for append-only file operations:

    appendonly-liburing yes
    liburing-queue-depth xl
    liburing-retry-count xl
    liburing-sqpoll no

### Running redis-benchmark

To run the benchmark tests, use the `redis-benchmark` tool [here](https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/):

```sh
./src/redis-benchmark -t set,incr -n 500000 -q
```

This command will run benchmark tests for the set and incr operations with 500,000 requests, providing a quick summary of the results.

## Scripts

Below is a detailed explanation of the main scripts and their functionalities.

- **`run_benchmarks.py`**: This script is designed to run benchmarks for different Redis modes and persistence configurations. It should be run with `sudo` because `strace` requires elevated privileges. It offers several command-line arguments for flexibility:

  - `--benchmark <arg>`: Specifies the benchmark to run. Options include `AOF`, `RDB`, `URING_AOF`.
  - `--requests <arg>`: Specifies the number of requests for the benchmark test.

  The workload for collecting metrics is generated by running:

  ```sh
  ./redis-benchmark -t set,incr -n {request_number}
  ```

**Usage Examples**:

- To run benchmarks with AOF:
  ```
  sudo python3 run_benchmarks.py --benchmark AOF --requests 10000
  ```
- To run benchmarks with RDB:
  ```
  sudo python3 run_benchmarks.py --benchmark RDB --requests 10000
  ```
- To run benchmarks with URING_AOF:
  ```
  sudo python3 run_benchmarks.py --benchmark URING_AOF --requests 10000
  ```

**Data and Logs**:

- **Benchmark Data**: Each Redis configuration directory stores its respective benchmark data. For example, data for the AOF configuration is stored in `benchmarks/<config>/csvs`.
- **Logs**: Logs from different Python scripts, including the latest Redis server logs, are stored in the same directories. For example, logs for the AOF configuration are found in `benchmarks/<config>/logs`.
- **Temporary Directory**: The `temp` directory is used for the current Redis instance to generate the AOF file. This allows for manual inspection if needed.

- **`plot.py`**: This script includes functionality for plotting comparisons between system calls, system call times, requests per second (RPS), CPU load, memory usage, and latency boxplots for different configurations. Additionally, it can generate a table comparing system call times across different persistence modes.

  **Arguments**:

  - `--csv_rdb`: Path to the CSV file for RDB results.
  - `--csv_aof`: Path to the CSV file for AOF results.
  - `--csv_aofuring`: Path to the CSV file for AOFUring results.
  - `--dir`: Directory to save the graph. Default is the current directory.
  - `--type`: Type of graph or table to generate. Options are:
    - `rps`: Generates a bar chart comparing Requests Per Second (RPS) across different persistence modes.
    - `syscalls`: Generates a bar chart comparing system call counts across different persistence modes.
    - `cpu`: Generates a bar chart comparing CPU usage across different persistence modes.
    - `memory`: Generates a bar chart comparing memory usage across different persistence modes.
    - `latency`: Generates a boxplot comparing latencies across different persistence modes.
    - `syscall_times`: Generates a table comparing system call times (in milliseconds) across different persistence modes.
    - `all`: Generates all of the above plots and the table.

  **Usage**:

  - To plot RPS comparisons:
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type rps
    ```
  - To plot system call comparisons:
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type syscalls
    ```
  - To plot CPU usage comparisons:
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type cpu
    ```
  - To plot memory usage comparisons:
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type memory
    ```
  - To plot latency comparisons (boxplot with log scale):
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type latency
    ```
  - To generate a table comparing system call times (in milliseconds):
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type syscall_times
    ```
  - To generate all plots and the system call times table:
    ```sh
    python3 plot.py --csv_rdb path/to/rdb.csv --csv_aof path/to/aof.csv --csv_aofuring path/to/aofuring.csv --dir output --type all
    ```


### Data Persistence Test

- **`data-persist-test.py`**: This script runs tests to set a specified number of request keys, restarts the server to rewrite its state from the AOF file, and then retrieves the data using the Redis library. After, Sets the same key for given request number of iterations, and checks if the key is equal to request number. After this, it runs an increment test that increments a key up to the request count, restarts the server, and checks if the key value is equal to the request count. This is a simple test, and due to time constraints, a more thorough test could not be written. Additionally, before reloading the AOF, the script runs `redis-check-aof` to check for corruption in the AOF file.

  **Arguments**:

  - `<requests>`: Specifies the number of requests to be tested (e.g., `1000`).

  **Usage**:

  - To run the data persistence test with 1000 requests:
    ```sh
    python3 data-persist-test.py 1000
    ```

  **Data**:

  - The data generated by this script is saved under the `data-persistence` directory.

    This script ensures that the Redis server can correctly recover its state from the AOF file after a restart, and that it maintains data integrity even after increment operations.
